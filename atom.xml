<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>John Doe</title>
  
  <subtitle>未曾清贫难做人，不经打击永天真。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-25T15:33:51.416Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式之单例模式</title>
    <link href="http://yoursite.com/2018/04/25/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/04/25/Java设计模式之单例模式/</id>
    <published>2018-04-24T16:26:30.000Z</published>
    <updated>2018-04-25T15:33:51.416Z</updated>
    
    <content type="html"><![CDATA[<p>Singleton是一种创建型模式，指某个类采用Singleton模式，则在这个类被创建后，只可能产生一个实例供外部访问，并且提供一个全局的访问点。</p><p>核心知识点如下：</p><p>(1) 将采用单例设计模式的类的构造方法私有化（采用private修饰）。</p><p>(2) 在其内部产生该类的实例化对象，并将其封装成private static类型。</p><p>(3) 定义一个静态方法返回该类的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 方法一</div><div class="line"> * 单例模式的实现：饿汉式,线程安全 但效率比较低 </div><div class="line"> */  </div><div class="line">public class SingletonTest &#123;  </div><div class="line"></div><div class="line">    // 定义一个私有的构造方法</div><div class="line">    private SingletonTest() &#123;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    // 将自身的实例对象设置为一个属性,并加上Static和final修饰符</div><div class="line">    private static final SingletonTest instance = new SingletonTest();  </div><div class="line"></div><div class="line">    // 静态方法返回该类的实例</div><div class="line">    public static SingletonTest getInstancei() &#123;  </div><div class="line">        return instance;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><br>方法一就是传说的中的饿汉模式<br>优点是：写起来比较简单，而且不存在多线程同步问题，避免了synchronized所造成的性能问题；<br>缺点是：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line"> *方法二</div><div class="line"> * 单例模式的实现：饱汉式,非线程安全   </div><div class="line"> *   </div><div class="line"> */  </div><div class="line">public class SingletonTest &#123;</div><div class="line"></div><div class="line">    // 定义私有构造方法（防止通过 new SingletonTest()去实例化）</div><div class="line">    private SingletonTest() &#123;   </div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    // 定义一个SingletonTest类型的变量（不初始化，注意这里没有使用final关键字）</div><div class="line">    private static SingletonTest instance;   </div><div class="line"></div><div class="line">    // 定义一个静态的方法（调用时再初始化SingletonTest，但是多线程访问时，可能造成重复初始化问题）</div><div class="line">    public static SingletonTest getInstance() &#123;   </div><div class="line">        if (instance == null)   </div><div class="line">            instance = new SingletonTest();   </div><div class="line">        return instance;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><br>方法二就是传说的中的饱汉模式<br>优点是：写起来比较简单，当类SingletonTest被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存；<br>缺点是：并发环境下很可能出现多个SingletonTest实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line"> *方法三</div><div class="line"> * 单例模式的实现：饱汉式,线程安全简单实现   </div><div class="line"> *   </div><div class="line"> */  </div><div class="line">public class SingletonTest &#123;</div><div class="line"></div><div class="line">    // 定义私有构造方法（防止通过 new SingletonTest()去实例化）</div><div class="line">    private SingletonTest() &#123;   </div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    // 定义一个SingletonTest类型的变量（不初始化，注意这里没有使用final关键字）</div><div class="line">    private static SingletonTest instance;   </div><div class="line"></div><div class="line">    // 定义一个静态的方法（调用时再初始化SingletonTest，使用synchronized 避免多线程访问时，可能造成重的复初始化问题）</div><div class="line">    public static synchronized  SingletonTest getInstance() &#123;   </div><div class="line">        if (instance == null)   </div><div class="line">            instance = new SingletonTest();   </div><div class="line">        return instance;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><br>方法三为方法二的简单优化<br>优点是：使用synchronized关键字避免多线程访问时，出现多个SingletonTest实例。<br>缺点是：同步方法频繁调用时，效率略低。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**  </div><div class="line"> * 方法四</div><div class="line"> * 单例模式最优方案</div><div class="line"> * 线程安全  并且效率高  </div><div class="line"> *  </div><div class="line"> */  </div><div class="line">public class SingletonTest &#123; </div><div class="line"></div><div class="line">    // 定义一个私有构造方法</div><div class="line">    private SingletonTest() &#123; </div><div class="line">     </div><div class="line">    &#125;   </div><div class="line">    //定义一个静态私有变量(不初始化，不使用final关键字，使用volatile保证了多线程访问时instance变量的可见性，避免了instance初始化时其他变量属性还没赋值完时，被另外线程调用)</div><div class="line">    private static volatile SingletonTest instance;  </div><div class="line"></div><div class="line">    //定义一个共有的静态方法，返回该类型实例</div><div class="line">    public static SingletonTest getIstance() &#123; </div><div class="line">        // 对象实例化时与否判断（不使用同步代码块，instance不等于null时，直接返回对象，提高运行效率）</div><div class="line">        if (instance == null) &#123;</div><div class="line">            //同步代码块（对象未初始化时，使用同步代码块，保证多线程访问时对象在第一次创建后，不再重复被创建）</div><div class="line">            synchronized (SingletonTest.class) &#123;</div><div class="line">                //未初始化，则初始instance变量</div><div class="line">                if (instance == null) &#123;</div><div class="line">                    instance = new SingletonTest();   </div><div class="line">                &#125;   </div><div class="line">            &#125;   </div><div class="line">        &#125;   </div><div class="line">        return instance;   </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure><br>方法四为单例模式的最佳实现。内存占用地，效率高，线程安全，多线程操作原子性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Singleton是一种创建型模式，指某个类采用Singleton模式，则在这个类被创建后，只可能产生一个实例供外部访问，并且提供一个全局的访问点。&lt;/p&gt;
&lt;p&gt;核心知识点如下：&lt;/p&gt;
&lt;p&gt;(1) 将采用单例设计模式的类的构造方法私有化（采用private修饰）。&lt;/
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
